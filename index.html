<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seraph's Clone Wars</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caprasimo&display=swap" rel="stylesheet">
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #110e0e, #27262d);
        font-family: 'Caprasimo', cursive;
        overflow: hidden;
        color: #e9c6b6;
        padding: 20px;
      }

      #gameHeader {
        text-align: center;
        margin-bottom: 20px;
        width: 100%;
      }

      #gameTitle {
        font-size: 48px;
        font-weight: 400;
        color: #d58a49;
        text-shadow: 0 0 10px rgba(213, 138, 73, 0.7), 3px 3px 0 #5e1608;
        margin-bottom: 10px;
        letter-spacing: 1px;
      }

      #controlsInfo {
        background: rgba(39, 38, 45, 0.5);
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        max-width: 800px;
        margin: 0 auto;
        border: 1px solid #523a35;
        color: #ca9385;
        font-size: 16px;
      }

      #gameContainer {
        position: relative;
        width: 800px;
        height: 600px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        border-radius: 10px;
        overflow: hidden;
        background: #110e0e;
      }

      #gameCanvas {
        background: linear-gradient(to bottom, #27262d, #110e0e);
        display: block;
      }

      #uiOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 15px;
        pointer-events: none;
        z-index: 10;
      }

      .health-bar,
      .exp-bar {
        background-color: rgba(39, 38, 45, 0.8);
        height: 20px;
        width: 250px;
        border-radius: 10px;
        margin-bottom: 10px;
        overflow: hidden;
        border: 2px solid #977e79;
      }

      .health-fill {
        height: 100%;
        background: linear-gradient(to right, #954e3f, #d58a49);
        width: 100%;
        transition: width 0.3s;
      }

      .exp-fill {
        height: 100%;
        background: linear-gradient(to right, #4e6278, #8899a6);
        width: 0%;
        transition: width 0.3s;
      }

      .stat {
        margin-top: 5px;
        font-size: 16px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        color: #e9c6b6;
      }

      #levelUpScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(17, 14, 14, 0.95);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        color: #e9c6b6;
        font-size: 24px;
      }

      #levelUpTitle {
        font-size: 48px;
        margin-bottom: 20px;
        color: #d58a49;
        text-shadow: 0 0 10px rgba(213, 138, 73, 0.7);
      }

      .upgrade-option {
        background: rgba(53, 21, 12, 0.8);
        border: 2px solid #977e79;
        border-radius: 10px;
        padding: 20px;
        margin: 15px;
        width: 80%;
        cursor: pointer;
        transition: all 0.3s;
        text-align: center;
      }

      .upgrade-option:hover {
        background: rgba(113, 87, 83, 0.9);
        transform: scale(1.05);
        border-color: #d58a49;
      }

      .upgrade-name {
        font-size: 22px;
        font-weight: 400;
        color: #e9c6b6;
        margin-bottom: 10px;
      }

      .upgrade-desc {
        font-size: 18px;
        color: #ca9385;
      }

      .rarity-common {
        color: #aeb0b9;
      }

      .rarity-uncommon {
        color: #4e6278;
      }

      .rarity-rare {
        color: #8899a6;
      }

      .rarity-epic {
        color: #d58a49;
      }

      .rarity-legendary {
        color: #e6b077;
      }

      #startScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #110e0e, #27262d);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
      }

      #startButton {
        background: linear-gradient(to bottom, #954e3f, #5e1608);
        color: #e9c6b6;
        border: none;
        padding: 15px 40px;
        font-size: 24px;
        border-radius: 50px;
        cursor: pointer;
        margin-top: 30px;
        transition: all 0.3s;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        font-family: 'Caprasimo', cursive;
        font-weight: 400;
        border: 2px solid #977e79;
      }

      #startButton:hover {
        transform: scale(1.1);
        box-shadow: 0 7px 20px rgba(149, 78, 63, 0.5);
      }

      #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(17, 14, 14, 0.95);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 150;
        color: #e9c6b6;
      }

      #gameOverTitle {
        font-size: 72px;
        color: #954e3f;
        margin-bottom: 20px;
        text-shadow: 0 0 10px rgba(149, 78, 63, 0.7);
      }

      #finalScore {
        font-size: 36px;
        margin-bottom: 30px;
      }

      #restartButton {
        background: linear-gradient(to bottom, #4e6278, #27262d);
        color: #e9c6b6;
        border: none;
        padding: 15px 40px;
        font-size: 24px;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.3s;
        font-family: 'Caprasimo', cursive;
        font-weight: 400;
        border: 2px solid #8899a6;
      }

      #restartButton:hover {
        transform: scale(1.1);
      }

      #pauseOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(17, 14, 14, 0.7);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 50;
        color: #e9c6b6;
        font-size: 48px;
        text-align: center;
      }

      #pauseText {
        color: #d58a49;
        text-shadow: 0 0 10px rgba(213, 138, 73, 0.7);
        margin-bottom: 20px;
      }
    </style>
  </head>
  <body>
    <div id="gameHeader">
      <div id="gameTitle">Seraph's Clone Wars</div>
      <div id="controlsInfo">
        <p>A / D - Mover | ESPAÇO - Pular | MOUSE - Mirar (atira automaticamente) | CLIQUE ESQUERDO - Pausar</p>
      </div>
    </div>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      <div id="uiOverlay">
        <div class="health-bar">
          <div class="health-fill" id="healthFill"></div>
        </div>
        <div class="exp-bar">
          <div class="exp-fill" id="expFill"></div>
        </div>
        <div class="stat">Nível: <span id="levelDisplay">1</span>
        </div>
        <div class="stat">Pontuação: <span id="scoreDisplay">0</span>
        </div>
      </div>
      <div id="levelUpScreen">
        <div id="levelUpTitle">NÍVEL AUMENTADO!</div>
        <div class="upgrade-option" data-index="0">
          <div class="upgrade-name rarity-common">Catalyst — Dano do Projétil +2</div>
          <div class="upgrade-desc">Aumenta o dano base dos seus projéteis</div>
        </div>
        <div class="upgrade-option" data-index="1">
          <div class="upgrade-name rarity-uncommon">Eyesight — Chance Crítica +5%</div>
          <div class="upgrade-desc">Aumenta a chance de causar dano crítico</div>
        </div>
        <div class="upgrade-option" data-index="2">
          <div class="upgrade-name rarity-rare">Thunderbolt — Raios do céu</div>
          <div class="upgrade-desc">Chama 2 raios em posições aleatórias</div>
        </div>
      </div>
      <div id="startScreen">
        <button id="startButton">COMEÇAR JOGO</button>
      </div>
      <div id="gameOverScreen">
        <div id="gameOverTitle">FIM DE JOGO</div>
        <div id="finalScore">Pontuação: 0</div>
        <button id="restartButton">JOGAR NOVAMENTE</button>
      </div>
      <div id="pauseOverlay">
        <div id="pauseText">PAUSADO</div>
        <p>Clique novamente para continuar</p>
      </div>
    </div>
    <script>
      // CONFIGURAÇÕES BALANCEADAS
      const config = {
        player: {
          width: 30,
          height: 50,
          speed: 200, // Agora em pixels por segundo
          jumpForce: 400, // Agora em pixels por segundo
          gravity: 1000, // Agora em pixels por segundo²
          friction: 0.9,
          maxHealth: 100,
          shootCooldown: 0.2,
          minShootCooldown: 0.05 // LIMITE MÍNIMO ADICIONADO
        },
        projectile: {
          speed: 600, // Aumentado em 50% (era 400)
          radius: 6,
          baseDamage: 10,
          critChance: 0.2,
          critMultiplier: 2
        },
        enemy: {
          width: 40,
          height: 40,
          spawnRate: 1.5, // Inimigos por segundo
          moveSpeed: 120, // Agora em pixels por segundo
          minHeight: 300, // 50% da altura do canvas (aumentado de 180)
          shootCooldown: 0.33, // Reduzido para 1/3 (era 1)
          projectileSpeed: 120, // Reduzido para 60% (era 200)
          projectileDamage: 10,
          minDistance: 200 // Aumentado para manter distância
        },
        exp: {
          baseLevelUp: 100,
          growthFactor: 1.2
        },
        // Plataformas como decoração (sem colisão)
        platformDecor: [{
          x: 0,
          y: 500,
          width: 200,
          height: 20
        }, {
          x: 220,
          y: 450,
          width: 150,
          height: 20
        }, {
          x: 400,
          y: 400,
          width: 150,
          height: 20
        }, {
          x: 580,
          y: 450,
          width: 150,
          height: 20
        }, {
          x: 0,
          y: 350,
          width: 150,
          height: 20
        }, {
          x: 200,
          y: 300,
          width: 150,
          height: 20
        }, {
          x: 400,
          y: 250,
          width: 150,
          height: 20
        }, {
          x: 600,
          y: 300,
          width: 200,
          height: 20
        }]
      };
      // Estado do jogo
      const gameState = {
        player: null,
        enemies: [],
        projectiles: [],
        enemyProjectiles: [],
        particles: [],
        wisps: [],
        exp: 0,
        level: 1,
        expToNextLevel: config.exp.baseLevelUp,
        score: 0,
        lastSpawn: 0,
        gameTime: 0,
        upgrades: [],
        isLevelUp: false,
        gameOver: false,
        keys: {},
        mouse: {
          x: 0,
          y: 0
        },
        lastShot: 0,
        lastEnemyShot: 0,
        invincible: 0,
        wave: 1,
        waveTime: 0,
        isPaused: false,
        selectedUpgrades: new Set(),
        lastFrameTime: 0,
        upgradeStacks: {} // Novo objeto para rastrear stacks
      };
      // Sistema de upgrades com stacks CORRIGIDO
      const upgrades = [
        // Comuns
        {
          id: 'catalyst',
          name: 'Catalyst',
          desc: 'Dano do Projétil +2',
          rarity: 'common',
          maxStacks: 10,
          effect: (p, stacks) => {
            p.damageBonus = 2 * stacks;
          }
        }, {
          id: 'growth',
          name: 'Growth',
          desc: 'HP Máximo +10',
          rarity: 'common',
          maxStacks: 10,
          effect: (p) => {
            p.maxHealth += 10;
            p.health += 10;
          }
        }, {
          id: 'impulse',
          name: 'Impulse',
          desc: 'Altura do Pulo +10%',
          rarity: 'common',
          maxStacks: 5,
          effect: (p) => {
            p.jumpMultiplier *= 1.1;
          }
        }, {
          id: 'swift',
          name: 'Swift',
          desc: 'Velocidade de Movimento +10%',
          rarity: 'common',
          maxStacks: 5,
          effect: (p) => {
            p.speedMultiplier *= 1.1;
          }
        }, {
          id: 'stability',
          name: 'Stability',
          desc: 'Projétil aguenta +1 acerto',
          rarity: 'common',
          maxStacks: 5,
          effect: (p) => {
            p.projectileHits += 1;
          }
        },
        // Incomuns
        {
          id: 'eyesight',
          name: 'Eyesight',
          desc: 'Chance Crítica +5%',
          rarity: 'uncommon',
          maxStacks: 5,
          effect: (p) => {
            p.critChance += 0.05;
          }
        }, {
          id: 'resonance',
          name: 'Resonance',
          desc: 'Velocidade de Ataque +12%',
          rarity: 'uncommon',
          maxStacks: 5,
          effect: (p, stacks) => {
            p.attackSpeedMultiplier = 1 + (0.12 * stacks);
            p.shootCooldown = Math.max(config.player.minShootCooldown, config.player.shootCooldown / p.attackSpeedMultiplier);
          }
        }, {
          id: 'leech',
          name: 'Leech',
          desc: 'Roubo de Vida 3% do dano',
          rarity: 'uncommon',
          maxStacks: 5,
          effect: (p) => {
            p.lifeSteal = (p.lifeSteal || 0) + 0.03;
          }
        }, {
          id: 'precision',
          name: 'Precision',
          desc: 'Dano Crítico +20%',
          rarity: 'uncommon',
          maxStacks: 5,
          effect: (p) => {
            p.critMultiplier += 0.2;
          }
        },
        // Raros
        {
          id: 'catalyst+',
          name: 'Catalyst+',
          desc: 'Dano do Projétil +4',
          rarity: 'rare',
          maxStacks: 5, // LIMITE ADICIONADO
          effect: (p) => {
            p.damageBonus += 4;
          }
        }, {
          id: 'swift+',
          name: 'Swift+',
          desc: 'Velocidade de Movimento +20%',
          rarity: 'rare',
          maxStacks: 5,
          effect: (p) => {
            p.speedMultiplier *= 1.2;
          }
        }, {
          id: 'thunderbolt',
          name: 'Thunderbolt',
          desc: 'Chama 2 raios do céu',
          rarity: 'rare',
          maxStacks: 5,
          effect: (p) => {
            p.thunderbolt = {
              count: (p.thunderbolt?.count || 0) + 2,
              interval: 3,
              timer: 0
            };
          }
        }, {
          id: 'gush',
          name: 'Gush',
          desc: '+1 Pulo Adicional',
          rarity: 'rare',
          maxStacks: 3,
          effect: (p) => {
            p.maxJumps = (p.maxJumps || 1) + 1;
          }
        }, {
          id: 'will-o-wisp',
          name: 'Will-O-Wisp',
          desc: 'Invoca uma chama aliada',
          rarity: 'rare',
          maxStacks: 5,
          effect: (p) => {
            p.wispCount = (p.wispCount || 0) + 1;
          }
        },
        // Épicos
        {
          id: 'fragmentation',
          name: 'Fragmentation',
          desc: 'Inimigos liberam 2 projéteis',
          rarity: 'epic',
          maxStacks: 5,
          effect: (p) => {
            p.fragmentation = (p.fragmentation || 0) + 2;
          }
        }, {
          id: 'barrier',
          name: 'Barrier',
          desc: 'Escudo bloqueador de dano',
          rarity: 'epic',
          maxStacks: 5,
          effect: (p) => {
            p.barrier = {
              interval: 8,
              timer: 0,
              active: false,
              count: (p.barrier?.count || 0) + 1
            };
          }
        }, {
          id: 'overheat',
          name: 'Overheat',
          desc: 'Contato corpo a corpo causa 40 de dano',
          rarity: 'epic',
          maxStacks: 5,
          effect: (p) => {
            p.contactDamage = (p.contactDamage || 0) + 40;
          }
        }, {
          id: 'immortal',
          name: 'Immortal',
          desc: '+1 Revive (mata todos ao reviver)',
          rarity: 'epic',
          maxStacks: 3,
          effect: (p) => {
            p.revives = (p.revives || 0) + 1;
          }
        },
        // Lendários
        {
          id: 'thunderbolt+',
          name: 'Thunderbolt+',
          desc: 'Chama 4 raios do céu',
          rarity: 'legendary',
          maxStacks: 3,
          effect: (p) => {
            if (p.thunderbolt) {
              p.thunderbolt.count += 4;
            } else {
              p.thunderbolt = {
                count: 4,
                interval: 3,
                timer: 0
              };
            }
          }
        }, {
          id: 'fragmentation+',
          name: 'Fragmentation+',
          desc: 'Inimigos liberam 4 projéteis',
          rarity: 'legendary',
          maxStacks: 3,
          effect: (p) => {
            p.fragmentation = (p.fragmentation || 0) + 4;
          }
        }, {
          id: 'appraisal',
          name: 'Appraisal',
          desc: '+1 escolha de upgrade',
          rarity: 'legendary',
          maxStacks: 2,
          effect: (p) => {
            p.extraChoices = (p.extraChoices || 0) + 1;
          }
        }
      ];
      // Classe Player
      class Player {
        constructor() {
          this.width = config.player.width;
          this.height = config.player.height;
          this.x = 400;
          this.y = 300;
          this.velX = 0;
          this.velY = 0;
          this.baseSpeed = config.player.speed;
          this.speedMultiplier = 1;
          this.baseJumpForce = config.player.jumpForce;
          this.jumpMultiplier = 1;
          this.gravity = config.player.gravity;
          this.friction = config.player.friction;
          this.grounded = false;
          this.jumps = 0;
          this.maxJumps = 1;
          this.health = 100;
          this.maxHealth = 100;
          this.baseDamage = config.projectile.baseDamage;
          this.damageBonus = 0;
          this.critChance = config.projectile.critChance;
          this.critMultiplier = config.projectile.critMultiplier;
          this.shootCooldown = config.player.shootCooldown;
          this.projectileHits = 1;
          this.lifeSteal = 0;
          this.thunderbolt = null;
          this.wispCount = 0;
          this.fragmentation = 0;
          this.barrier = null;
          this.contactDamage = 0;
          this.revives = 0;
          this.extraChoices = 0;
          this.attackSpeedMultiplier = 1; // Novo multiplicador
        }
        get speed() {
          return this.baseSpeed * this.speedMultiplier;
        }
        get jumpForce() {
          return this.baseJumpForce * this.jumpMultiplier;
        }
        get damage() {
          return this.baseDamage + this.damageBonus;
        }
        update(deltaTime) {
          if (gameState.isPaused || gameState.isLevelUp) return;
          // Movimento horizontal
          if (gameState.keys['a'] || gameState.keys['ArrowLeft']) {
            this.velX = -this.speed;
          } else if (gameState.keys['d'] || gameState.keys['ArrowRight']) {
            this.velX = this.speed;
          } else {
            this.velX *= this.friction;
          }
          // Gravidade
          this.velY += this.gravity * deltaTime;
          // Atualizar posição
          this.x += this.velX * deltaTime;
          this.y += this.velY * deltaTime;
          // Limitar ao canvas
          if (this.x < 0) this.x = 0;
          if (this.x > 800 - this.width) this.x = 800 - this.width;
          if (this.y > 600 - this.height) {
            this.y = 600 - this.height;
            this.velY = 0;
            this.grounded = true;
            this.jumps = 0;
          }
          // Atirar continuamente na direção do mouse
          const now = Date.now() / 1000;
          if (now - gameState.lastShot > this.shootCooldown) {
            this.shoot();
            gameState.lastShot = now;
          }
          // Atualizar habilidades
          if (this.thunderbolt) {
            this.thunderbolt.timer += deltaTime;
            if (this.thunderbolt.timer >= this.thunderbolt.interval) {
              this.castThunderbolt();
              this.thunderbolt.timer = 0;
            }
          }
          if (this.barrier) {
            this.barrier.timer += deltaTime;
            if (this.barrier.timer >= this.barrier.interval) {
              this.barrier.active = true;
              this.barrier.timer = 0;
            }
          }
          // Atualizar Wisps
          if (this.wispCount > gameState.wisps.length) {
            gameState.wisps.push(new WillOWisp(gameState.wisps.length));
          }
        }
        jump() {
          if (this.grounded || this.jumps < this.maxJumps) {
            this.velY = -this.jumpForce;
            this.grounded = false;
            this.jumps++;
          }
        }
        shoot() {
          const angle = Math.atan2(gameState.mouse.y - (this.y + this.height / 2), gameState.mouse.x - (this.x + this.width / 2));
          const isCrit = Math.random() < this.critChance;
          const damage = isCrit ? this.damage * this.critMultiplier : this.damage;
          gameState.projectiles.push({
            x: this.x + this.width / 2,
            y: this.y + this.height / 2,
            velX: Math.cos(angle) * config.projectile.speed,
            velY: Math.sin(angle) * config.projectile.speed,
            radius: config.projectile.radius,
            damage: damage,
            isCrit: isCrit,
            hits: this.projectileHits
          });
        }
        castThunderbolt() {
          for (let i = 0; i < this.thunderbolt.count; i++) {
            // Raios em posições aleatórias
            const randomX = Math.random() * 700 + 50;
            gameState.projectiles.push({
              x: randomX,
              y: 0,
              velX: 0,
              velY: 3 * config.projectile.speed,
              radius: 10,
              damage: this.damage * 5,
              isCrit: true,
              hits: 1
            });
          }
        }
        takeDamage(amount) {
          if (gameState.invincible > 0) return;
          if (this.barrier && this.barrier.active) {
            this.barrier.active = false;
            this.barrier.timer = 0;
            return;
          }
          this.health -= amount;
          gameState.invincible = 0.5;
          if (this.health <= 0) {
            if (this.revives > 0) {
              this.revives--;
              this.health = this.maxHealth;
              gameState.invincible = 3.0; // CORREÇÃO ADICIONADA
              // Matar todos os inimigos ao reviver
              gameState.enemies = [];
              gameState.enemyProjectiles = [];
              gameState.particles = [];
            } else {
              gameState.gameOver = true;
              document.getElementById('gameOverScreen').style.display = 'flex';
              document.getElementById('finalScore').textContent = `Pontuação: ${gameState.score}`;
            }
          }
        }
        draw(ctx) {
          // Desenhar jogador
          ctx.fillStyle = gameState.invincible > 0 ? 'rgba(213, 138, 73, 0.5)' : '#d58a49';
          ctx.fillRect(this.x, this.y, this.width, this.height);
          // Desenhar olhos
          ctx.fillStyle = '#e9c6b6';
          ctx.fillRect(this.x + 5, this.y + 10, 8, 8);
          ctx.fillRect(this.x + this.width - 13, this.y + 10, 8, 8);
          // Desenhar barreira se ativa
          if (this.barrier && this.barrier.active) {
            ctx.strokeStyle = '#8899a6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width + 10, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }
      // Classe Will-O-Wisp
      class WillOWisp {
        constructor(index) {
          this.radius = 12;
          this.offsetAngle = (index / 3) * Math.PI * 2;
          this.shootTimer = 0;
          this.shootCooldown = 1.5;
        }
        update(deltaTime) {
          if (gameState.isPaused || gameState.isLevelUp) return;
          this.shootTimer += deltaTime;
          if (this.shootTimer >= this.shootCooldown) {
            this.shoot();
            this.shootTimer = 0;
          }
        }
        shoot() {
          // Encontrar o inimigo mais próximo
          let closestEnemy = null;
          let minDistance = Infinity;
          for (const enemy of gameState.enemies) {
            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < minDistance) {
              minDistance = distance;
              closestEnemy = enemy;
            }
          }
          if (closestEnemy) {
            const angle = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x);
            gameState.projectiles.push({
              x: this.x,
              y: this.y,
              velX: Math.cos(angle) * config.projectile.speed * 0.7,
              velY: Math.sin(angle) * config.projectile.speed * 0.7,
              radius: 8,
              damage: gameState.player.damage * 0.5,
              isCrit: false,
              hits: 1
            });
          }
        }
        get x() {
          return gameState.player.x + gameState.player.width / 2 + Math.cos(this.offsetAngle + gameState.gameTime * 2) * 50;
        }
        get y() {
          return gameState.player.y + gameState.player.height / 2 + Math.sin(this.offsetAngle + gameState.gameTime * 2) * 50;
        }
        draw(ctx) {
          // Garantir que a Will-O-Wisp fique dentro da tela
          const canvasX = Math.max(this.radius, Math.min(this.x, 800 - this.radius));
          const canvasY = Math.max(this.radius, Math.min(this.y, 600 - this.radius));
          // Desenhar Will-O-Wisp
          ctx.fillStyle = '#e6b077';
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, this.radius, 0, Math.PI * 2);
          ctx.fill();
          // Brilho interior
          ctx.fillStyle = '#ffd700';
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, this.radius * 0.6, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Classe Enemy
      class Enemy {
        constructor() {
          this.width = config.enemy.width;
          this.height = config.enemy.height;
          this.x = Math.random() * (800 - this.width);
          this.y = -this.height;
          this.velY = config.enemy.moveSpeed;
          this.following = false;
          this.health = 20 + gameState.wave * 3;
          this.maxHealth = 20 + gameState.wave * 3;
          this.shootTimer = 0;
          this.targetX = this.x;
          this.targetY = config.enemy.minHeight;
          this.directionX = Math.random() > 0.5 ? 1 : -1;
          this.startHeight = 0;
        }
        update(deltaTime) {
          if (gameState.isPaused || gameState.isLevelUp) return;
          if (!this.following) {
            // Movimento horizontal reduzido em 70%
            const dx = this.targetX - (this.x + this.width / 2);
            this.x += dx * 0.003 * deltaTime * 60; // Reduzido em 70%
            // Movimento vertical com limite
            this.y += this.velY * deltaTime;
            // Não permitir descer abaixo de 50% da altura
            if (this.y >= config.enemy.minHeight) {
              this.y = config.enemy.minHeight;
              this.following = true;
              this.startHeight = this.y; // Armazenar altura inicial
            }
            // Mudar direção ocasionalmente
            if (Math.random() < 0.01) {
              this.directionX = Math.random() > 0.5 ? 1 : -1;
            }
            this.targetX += this.directionX * 2 * deltaTime * 60;
            // Limitar ao canvas
            this.targetX = Math.max(50, Math.min(this.targetX, 750));
            // Atirar durante a descida
            this.shootTimer += deltaTime;
            if (this.shootTimer > 1 / config.enemy.shootCooldown) {
              this.shoot();
              this.shootTimer = 0;
            }
          } else {
            // Seguir o jogador mantendo altura
            const dx = gameState.player.x + gameState.player.width / 2 - (this.x + this.width / 2);
            const distance = Math.abs(dx);
            // Movimento horizontal reduzido em 70%
            this.x += dx * 0.005 * deltaTime * 60; // Reduzido em 70%
            // Manter a altura inicial
            this.y = this.startHeight;
            // Atirar periodicamente
            this.shootTimer += deltaTime;
            if (this.shootTimer > 1 / config.enemy.shootCooldown) {
              this.shoot();
              this.shootTimer = 0;
            }
          }
          // Limitar ao canvas
          if (this.x < 0) this.x = 0;
          if (this.x > 800 - this.width) this.x = 800 - this.width;
          if (this.y < 0) this.y = 0;
          if (this.y > 600 - this.height) this.y = 600 - this.height;
        }
        shoot() {
          const angle = Math.atan2(
            (gameState.player.y + gameState.player.height / 2) - (this.y + this.height / 2),
            (gameState.player.x + gameState.player.width / 2) - (this.x + this.width / 2));
          gameState.enemyProjectiles.push({
            x: this.x + this.width / 2,
            y: this.y + this.height / 2,
            velX: Math.cos(angle) * config.enemy.projectileSpeed,
            velY: Math.sin(angle) * config.enemy.projectileSpeed,
            radius: 6,
            damage: config.enemy.projectileDamage
          });
        }
        takeDamage(amount) {
          this.health -= amount;
          if (this.health <= 0) {
            // Adicionar EXP e pontuação
            const expGain = 10 + gameState.wave * 2;
            gameState.exp += expGain;
            gameState.score += expGain;
            // Verificar se subiu de nível
            if (gameState.exp >= gameState.expToNextLevel) {
              gameState.level++;
              gameState.exp -= gameState.expToNextLevel;
              gameState.expToNextLevel = Math.floor(config.exp.baseLevelUp * Math.pow(config.exp.growthFactor, gameState.level - 1));
              gameState.isLevelUp = true;
              document.getElementById('levelUpScreen').style.display = 'flex';
              generateUpgradeOptions();
            }
            // Criar partículas de explosão
            for (let i = 0; i < 15; i++) {
              gameState.particles.push({
                x: this.x + this.width / 2,
                y: this.y + this.height / 2,
                velX: (Math.random() - 0.5) * 6,
                velY: (Math.random() - 0.5) * 6,
                radius: Math.random() * 4 + 2,
                color: '#954e3f',
                life: 1.0
              });
            }
            // Fragmentação se o jogador tiver essa habilidade
            if (gameState.player.fragmentation > 0) {
              for (let i = 0; i < gameState.player.fragmentation; i++) {
                const angle = Math.random() * Math.PI * 2;
                gameState.projectiles.push({
                  x: this.x + this.width / 2,
                  y: this.y + this.height / 2,
                  velX: Math.cos(angle) * config.projectile.speed * 0.7,
                  velY: Math.sin(angle) * config.projectile.speed * 0.7,
                  radius: config.projectile.radius * 0.7,
                  damage: gameState.player.damage * 0.5,
                  isCrit: false,
                  hits: 1
                });
              }
            }
            return true; // Inimigo morto
          }
          return false;
        }
        draw(ctx) {
          ctx.fillStyle = '#954e3f';
          ctx.fillRect(this.x, this.y, this.width, this.height);
          // Desenhar olhos
          ctx.fillStyle = '#e9c6b6';
          ctx.fillRect(this.x + 10, this.y + 15, 6, 6);
          ctx.fillRect(this.x + this.width - 16, this.y + 15, 6, 6);
          // Barra de vida
          const healthPercent = this.health / this.maxHealth;
          ctx.fillStyle = 'rgba(39, 38, 45, 0.7)';
          ctx.fillRect(this.x, this.y - 10, this.width, 5);
          ctx.fillStyle = healthPercent > 0.5 ? '#4e6278' : healthPercent > 0.25 ? '#8899a6' : '#954e3f';
          ctx.fillRect(this.x, this.y - 10, this.width * healthPercent, 5);
        }
      }
      // Inicialização do jogo - CORREÇÃO ADICIONADA
      function initGame() {
        gameState.player = new Player();
        gameState.enemies = [];
        gameState.projectiles = [];
        gameState.enemyProjectiles = [];
        gameState.particles = [];
        gameState.wisps = [];
        gameState.exp = 0;
        gameState.level = 1;
        gameState.expToNextLevel = config.exp.baseLevelUp;
        gameState.score = 0;
        gameState.lastSpawn = 0;
        gameState.gameTime = 0;
        gameState.upgrades = [];
        gameState.isLevelUp = false;
        gameState.gameOver = false;
        gameState.wave = 1;
        gameState.waveTime = 0;
        gameState.invincible = 0;
        gameState.isPaused = false;
        gameState.selectedUpgrades = new Set(); // RESETAR UPGRADES SELECIONADOS
        gameState.upgradeStacks = {}; // RESETAR CONTADORES DE STACKS
        gameState.lastFrameTime = performance.now();
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('levelUpScreen').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('pauseOverlay').style.display = 'none';
      }

      function generateUpgradeOptions() {
        const container = document.getElementById('levelUpScreen');
        const numChoices = 3 + (gameState.player.extraChoices || 0);
        // Remover opções existentes
        const existingOptions = container.querySelectorAll('.upgrade-option');
        existingOptions.forEach(opt => opt.remove());
        // Criar novas opções
        gameState.currentUpgrades = [];
        const availableUpgrades = [...upgrades].filter(u => (!u.maxStacks || (gameState.upgradeStacks[u.id] || 0) < u.maxStacks));
        // Selecionar upgrades
        for (let i = 0; i < numChoices; i++) {
          if (availableUpgrades.length === 0) break;
          const index = Math.floor(Math.random() * availableUpgrades.length);
          const upgrade = availableUpgrades[index];
          availableUpgrades.splice(index, 1);
          // Criar elemento DOM
          const option = document.createElement('div');
          option.className = 'upgrade-option';
          option.dataset.index = i;
          option.innerHTML = `
								<div class="upgrade-name rarity-${upgrade.rarity}">${upgrade.name} — ${upgrade.desc}</div>
								<div class="upgrade-desc">${upgrade.desc}</div>`;
          option.addEventListener('click', () => applyUpgrade(i));
          container.appendChild(option);
          gameState.currentUpgrades.push(upgrade);
        }
      }
      // Função para aplicar upgrade modificada - CORREÇÃO PRINCIPAL
      function applyUpgrade(index) {
        const upgrade = gameState.currentUpgrades[index];
        // Inicializar contador de stacks se necessário
        if (!gameState.upgradeStacks[upgrade.id]) {
          gameState.upgradeStacks[upgrade.id] = 0;
        }
        // Verificar limite APENAS se maxStacks estiver definido
        if (upgrade.maxStacks && gameState.upgradeStacks[upgrade.id] >= upgrade.maxStacks) {
          alert(`Você atingiu o limite máximo (${upgrade.maxStacks}) para este upgrade!`);
          return;
        }
        // Aplicar efeito
        gameState.upgradeStacks[upgrade.id]++;
        if (upgrade.effect.length === 2) {
          upgrade.effect(gameState.player, gameState.upgradeStacks[upgrade.id]);
        } else {
          upgrade.effect(gameState.player);
        }
        gameState.upgrades.push(upgrade);
        gameState.isLevelUp = false;
        document.getElementById('levelUpScreen').style.display = 'none';
      }
      // Função para desenhar plataformas decorativas
      function drawPlatformDecor(ctx) {
        for (const platform of config.platformDecor) {
          // Gradiente para as plataformas
          const gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
          gradient.addColorStop(0, '#523a35');
          gradient.addColorStop(1, '#35150c');
          ctx.fillStyle = gradient;
          ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
          // Detalhes superiores
          ctx.fillStyle = '#714936';
          for (let i = 0; i < platform.width; i += 20) {
            ctx.fillRect(platform.x + i, platform.y, 15, 5);
          }
        }
      }
      // Alternar pausa
      function togglePause() {
        gameState.isPaused = !gameState.isPaused;
        document.getElementById('pauseOverlay').style.display = gameState.isPaused ? 'flex' : 'none';
      }
      // Loop principal do jogo
      function gameLoop(currentTime) {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Calcular delta time
        const deltaTime = (currentTime - gameState.lastFrameTime) / 1000;
        gameState.lastFrameTime = currentTime;
        // Limpar canvas
        ctx.clearRect(0, 0, 800, 600);
        // Desenhar fundo estético
        drawPlatformDecor(ctx);
        // Atualizar e desenhar partículas
        for (let i = gameState.particles.length - 1; i >= 0; i--) {
          const p = gameState.particles[i];
          if (!gameState.isPaused && !gameState.isLevelUp) {
            p.x += p.velX * deltaTime * 60;
            p.y += p.velY * deltaTime * 60;
            p.life -= 0.02 * deltaTime * 60;
          }
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
          if (p.life <= 0) {
            gameState.particles.splice(i, 1);
          }
        }
        // Atualizar e desenhar projéteis do jogador
        for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
          const p = gameState.projectiles[i];
          if (!gameState.isPaused && !gameState.isLevelUp) {
            p.x += p.velX * deltaTime;
            p.y += p.velY * deltaTime;
          }
          // Desenhar projétil
          ctx.fillStyle = p.isCrit ? '#e6b077' : '#8899a6';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
          // Verificar colisão com inimigos (CORREÇÃO STABILITY)
          let hit = false;
          for (let j = gameState.enemies.length - 1; j >= 0; j--) {
            const e = gameState.enemies[j];
            // Pular se já atingiu este inimigo
            if (p.hitEnemies && p.hitEnemies.includes(e.id)) continue;
            if (p.x > e.x && p.x < e.x + e.width && p.y > e.y && p.y < e.y + e.height) {
              // Inicializar lista de inimigos atingidos
              if (!p.hitEnemies) p.hitEnemies = [];
              p.hitEnemies.push(e.id);
              const killed = e.takeDamage(p.damage);
              if (killed) gameState.enemies.splice(j, 1);
              // Roubo de vida
              if (gameState.player.lifeSteal > 0) {
                gameState.player.health += p.damage * gameState.player.lifeSteal;
              }
              p.hits--;
              if (p.hits <= 0) {
                hit = true;
                break;
              }
            }
          }
          // Remover projétil se necessário
          if (hit || p.x < -50 || p.x > 850 || p.y < -50 || p.y > 650) {
            gameState.projectiles.splice(i, 1);
          }
        }
        // Atualizar e desenhar projéteis inimigos
        for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
          const p = gameState.enemyProjectiles[i];
          if (!gameState.isPaused && !gameState.isLevelUp) {
            p.x += p.velX * deltaTime;
            p.y += p.velY * deltaTime;
          }
          // Desenhar projétil inimigo
          ctx.fillStyle = '#954e3f';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
          // Verificar colisão com jogador
          if (Math.abs(p.x - (gameState.player.x + gameState.player.width / 2)) < gameState.player.width / 2 + p.radius && Math.abs(p.y - (gameState.player.y + gameState.player.height / 2)) < gameState.player.height / 2 + p.radius) {
            gameState.player.takeDamage(p.damage);
            gameState.enemyProjectiles.splice(i, 1);
          }
          // Remover se sair da tela
          else if (p.x < -50 || p.x > 850 || p.y < -50 || p.y > 650) {
            gameState.enemyProjectiles.splice(i, 1);
          }
        }
        // Atualizar e desenhar inimigos
        for (let i = gameState.enemies.length - 1; i >= 0; i--) {
          if (!gameState.isPaused && !gameState.isLevelUp) {
            gameState.enemies[i].update(deltaTime);
          }
          gameState.enemies[i].draw(ctx);
          // Verificar dano de contato
          if (gameState.player.contactDamage > 0) {
            const dx = Math.abs(gameState.player.x - gameState.enemies[i].x);
            const dy = Math.abs(gameState.player.y - gameState.enemies[i].y);
            if (dx < (gameState.player.width + gameState.enemies[i].width) / 2 && dy < (gameState.player.height + gameState.enemies[i].height) / 2) {
              const killed = gameState.enemies[i].takeDamage(gameState.player.contactDamage);
              if (killed) {
                gameState.enemies.splice(i, 1);
              }
            }
          }
        }
        // Atualizar e desenhar Wisps
        for (let i = gameState.wisps.length - 1; i >= 0; i--) {
          if (!gameState.isPaused && !gameState.isLevelUp) {
            gameState.wisps[i].update(deltaTime);
          }
          gameState.wisps[i].draw(ctx);
        }
        // Atualizar jogador
        if (!gameState.gameOver) {
          if (!gameState.isLevelUp) {
            gameState.player.update(deltaTime);
          }
          // Spawn de inimigos
          if (!gameState.isPaused && !gameState.isLevelUp) {
            gameState.lastSpawn += deltaTime;
            if (gameState.lastSpawn > 1 / config.enemy.spawnRate) {
              gameState.enemies.push(new Enemy());
              gameState.lastSpawn = 0;
            }
            // Atualizar tempo de jogo
            gameState.gameTime += deltaTime;
            gameState.waveTime += deltaTime;
            // Avançar de wave a cada 30 segundos
            if (gameState.waveTime > 30) {
              gameState.wave++;
              gameState.waveTime = 0;
            }
            // Atualizar invencibilidade (DENTRO DO BLOCO DE SPAWN)
            if (!gameState.isPaused && !gameState.isLevelUp) {
                if (gameState.invincible > 0) {
                    gameState.invincible -= deltaTime;
                }
            }
          }
        }
        // Desenhar jogador
        gameState.player.draw(ctx);
        // Atualizar UI
        document.getElementById('healthFill').style.width = `${(gameState.player.health / gameState.player.maxHealth) * 100}%`;
        document.getElementById('expFill').style.width = `${(gameState.exp / gameState.expToNextLevel) * 100}%`;
        document.getElementById('levelDisplay').textContent = gameState.level;
        document.getElementById('scoreDisplay').textContent = gameState.score;
        // Desenhar texto de wave
        ctx.fillStyle = '#e9c6b6';
        ctx.font = '24px Caprasimo';
        ctx.textAlign = 'right';
        ctx.fillText(`Wave: ${gameState.wave}`, 780, 30);
        // Continuar o loop
        if (!gameState.gameOver) {
          requestAnimationFrame(gameLoop);
        }
      }
      // Event Listeners
      document.getElementById('startButton').addEventListener('click', () => {
        initGame();
        requestAnimationFrame(gameLoop);
      });
      document.getElementById('restartButton').addEventListener('click', () => {
        initGame();
        requestAnimationFrame(gameLoop);
      });
      document.querySelectorAll('.upgrade-option').forEach(option => {
        option.addEventListener('click', () => {
          applyUpgrade(parseInt(option.getAttribute('data-index')));
        });
      });
      window.addEventListener('keydown', (e) => {
        gameState.keys[e.key] = true;
        if ((e.key === ' ' || e.key === 'Spacebar') && !gameState.isLevelUp && !gameState.gameOver && !gameState.isPaused) {
          gameState.player.jump();
        }
      });
      window.addEventListener('keyup', (e) => {
        gameState.keys[e.key] = false;
      });
      document.getElementById('gameCanvas').addEventListener('mousemove', (e) => {
        const rect = document.getElementById('gameCanvas').getBoundingClientRect();
        gameState.mouse.x = e.clientX - rect.left;
        gameState.mouse.y = e.clientY - rect.top;
      });
      // Pausar com clique esquerdo
      document.getElementById('gameCanvas').addEventListener('click', (e) => {
        if (!gameState.gameOver && !gameState.isLevelUp) {
          togglePause();
        }
      });
      // Permitir despausar clicando na overlay
      document.getElementById('pauseOverlay').addEventListener('click', () => {
        togglePause();
      });
      // Inicializar UI
      document.getElementById('healthFill').style.width = '100%';
      document.getElementById('expFill').style.width = '0%';
    </script>
  </body>
</html>